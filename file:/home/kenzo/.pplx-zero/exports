{
  "queries": [
    "React hooks performance optimization"
  ],
  "results": [
    {
      "title": "Performance Hooks in React",
      "url": "https://www.geeksforgeeks.org/reactjs/performance-hooks-in-react/",
      "snippet": "# Performance Hooks in React\n\n  \r\n\n  \r\n  Last Updated : 23 Jul, 2025\n\n  \r\n\n  While developing **React** Applications, optimizing performance is one of the most important things for delivering a seamless user experience. One common way to boost performance is to minimize unnecessary re-renders by skipping repetitive calculations. React provides two powerful hooks,\n  ```\n  useMemo\n  ```\n  and\n  ```\n  useCallback\n  ```\n  , which helps you to achieve optimization by caching results and function definitions, respectively. In this article, we'll learn about the functionalities of these hooks and explore how they can be effectively utilized to enhance React application performance.\n\n  **We will discuss about the following Performance Hooks in React:**\n\n  Table of Content\n\n  - useMemo Hook\n  - useCallback Hooks\n\n  Both\n  ```\n  useMemo\n  ```\n  and\n  ```\n  useCallback\n  ```\n  are part of React's hooks API introduced in React 16.8. While they serve different purposes, they share a common goal of optimizing performance by memoizing values and functions.... ## useMemo Hook\n\n  In React useMemo Hook returns a memoized value and prevents the application from unnecessary re-renders. It is useful in heavy computations and processes when using functional components.\n\n  ### Syntax:\n\n  ```\n  const memoizedValue = useMemo(functionThatReturnsValue, arrayDependencies)\n  ```\n\n  **Example: **In this example,** **we have used the number as the squareNum will run only when the number changes. If we increase the counter and the number remains the same in the input field the squareNum doesn‚Äôt run again.\n\n  ```\n\n  // Filename - App.js\n\n  import React, { useState, useMemo } from \"react\";\n\n  function App() {\n  const [number, setNumber] = useState(0);\n  // Using useMemo\n  const squaredNum = useMemo(() => {\n  return squareNum(number);\n  }, [number]);\n  const [counter, setCounter] = useState(0);\n\n  // Change the state to the input\n  const onChangeHandler = (e) => {\n  setNumber(e.target.value);\n  };\n\n  // Increases the counter by 1\n  const counterHander = () => {\n  setCounter(counter + 1);\n  };\n  return (\n  <div style={{marginLeft: \"20%\"}}>\n  <h1>Welcome to Geeksforgeeks</h1>\n  <input\n  type=\"number\"\n  placeholder=\"Enter a number\"\n  value={number}\n  onChange={onChangeHandler}>\n  </input>\n\n  <div>OUTPUT: {squaredNum}</div>\n  <button onClick={counterHander}>\n  Counter ++\n  </button>\n  <div>Counter : {counter}</div>\n  </div>\n  );\n  }\n\n  // Function to square the value\n  function squareNum(number) {\n  console.log(\"Squaring will be done!\");\n  return Math.pow(number, 2);\n  }\n\n  export default App;\n\n  ```\n\n  **Output:**... ## useCallback Hooks\n\n  The useCallback hook is used when you have a component in which the child is rerendering again and again without need.\n\n  Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.\n\n  ### Syntax:\n\n  ```\n  const memoizedCallback = useCallback( () => { doSomething(a, b); }, [a, b],);\n  ```\n\n  **Example: **When we change the state ‚Äòcount‚Äô then two functions will re-instantiated so the set size will increase by 2 and when we update the state ‚Äònumber‚Äô then only one function will re-instantiated and the size of the set will increase by only one.\n\n  ```\n\n  import React, { useState, useCallback } from 'react'\n  var funccount = new Set();\n  const App = () => {\n\n  const [count, setCount] = useState(0)\n  const [number, setNumber] = useState(0)\n\n  const incrementCounter = useCallback(() => {\n  setCount(count + 1)\n  }, [count])\n  const decrementCounter = useCallback(() => {\n  setCount(count - 1)\n  }, [count])\n  const incrementNumber = useCallback(() => {\n  setNumber(number + 1)\n  }, [number])\n\n  funccount.add(incrementCounter);\n  funccount.add(decrementCounter);\n  funccount.add(incrementNumber);\n  alert(funccount.size);\n\n  return (\n  <div>\n  Count: {count}\n  <button onClick={incrementCounter}>\n  Increase counter\n  </button>\n  <button onClick={decrementCounter}>\n  Decrease Counter\n  </button>\n  <button onClick={incrementNumber}>\n  increase number\n  </button>\n  </div>\n  )\n  }\n\n  export default App;\n\n  ```\n\n  **Output:**",
      "date": "2024-02-20"
    },
    {
      "title": "Performance optimization hooks in React",
      "url": "https://www.educative.io/answers/performance-optimization-hooks-in-react",
      "snippet": "Key Takeaways\n\nReact‚Äôs useCallback and useMemo hooks help optimize performance by reducing unnecessary re-renders. As React applications grow in size, unoptimized components may lead to slow user interfaces. Proper usage of these performance hooks ensures that React applications remain fast and responsive for an optimal user experience.\n\nuseCallback\n\nuseMemo\n\nWrapping components with React‚Äôs memo function ensures that a component only re-renders when its props change. This is an effective way to optimize child components that rely on stable props.\n\nmemo\n\nMemoization is the process of caching the results of functions or computations to reuse them when needed. The useCallback and useMemo hooks leverage memoization to improve the efficiency of function and value management by avoiding recalculating the same values on every render.\n\nWhen functions are passed as props to child components, React usually re-renders the child component on every parent render. The useCallback hook caches these functions so that React does not unnecessarily re-create the same function, ensuring that the child component only re-renders when needed.\n\nIf an application performs intensive calculations, such as sorting, filtering, or searching within large datasets, the useMemo hook ensures that these computations only run when required. This reduces the computational overhead and keeps the UI responsive, as React uses the cached value until dependencies change.... Developers who want to ensure that users have a positive user experience and keep them engaged in the application need to focus on improving application performance. React applications have a very fast UI by default, however, when the size of the application increases there might be performance issues.\n\nIn React, every time a component re-renders, all functions declared within that component are re-created. This behavior ensures that the component logic reflects the latest state, but it can lead to performance issues if the component is large or if certain functions are passed as props to child components. React does not re-render individual functions within a component. Instead, the entire component is re-rendered whenever its state or props change.\n\nIf a component has many functions, React recreates all of them on each render, even if some are not directly affected by the changes. This can make the application feel slower, especially when these functions are passed down to other components as props, causing child components to re-render unnecessarily. To avoid this scenario, we use the concept of memoization.\n\nNote: Memoization is not exclusive to React, but React offers tools to leverage this concept for performance optimization. It provides the memo function to memoize components and useCallback and useMemo hooks to optimize functions and computed values within components.\n\nReact‚Äôs memo function is used to memoize functional components. It prevents unnecessary re-renders by comparing the current and previous props through a shallow comparison. If the props are the same, React skips the re-render. However, if any prop has changed, the component will re-render to ensure the latest data is displayed.... Note: Memoization is not free, you are trading space for time.\n\nNow, what if we have separate functions that we are passing down as props to some other component? They will not be memoized by the memo function and will re-render every single time. This is because functions are re-created with a new reference on every render, making them appear as different objects to React.\n\nTo understand the use of the useCallback hook, you should have a slight understanding of the concept of referential integrityReferential integrity is when we create two variables and compare them with each other and the answer would be true because they are just comparing the values and the data type. In the case of objects, when we create two objects and compare them, the result would be false as the objects are pointing to two different memory blocks. So, when a slight change is made every time, it creates a new object that has a new memory address‚Äî breaking the referential integrity when the shallow comparison of props is made. Hence, we have to re-render the whole component again..\n\nWhen functions are passed as props to child components, React may re-render the child unnecessarily, even if the logic of the function hasn‚Äôt changed. This is where useCallback comes in. The useCallback hook memoizes a function, ensuring that it maintains the same reference across renders unless its dependencies change. This prevents React from triggering re-renders in child components that receive the function as a prop.... Haven‚Äôt found what you were looking for? Contact Us\n\nUse the useCallback hook when passing functions as props to prevent unnecessary re-renders of child components.\n\nYes! You can use useEffect hook alongside memoization hooks to run side effects based on memoized values or functions.\n\nuseEffect\n\nThe main difference between these two hooks is that the useMemo hook caches values while the useCallback hook caches functions.\n\nRelevant Answers\n\nExplore Courses\n\nFree Resources\n\n\n\nKey Takeaways\n\nReact‚Äôs\n\n`useCallback`and\n\n`useMemo`hooks help optimize performance by reducing unnecessary re-renders. As React applications grow in size, unoptimized components may lead to slow user interfaces. Proper usage of these performance hooks ensures that React applications remain fast and responsive for an optimal user experience.\n\nWrapping components with React‚Äôs\n\n`memo`function ensures that a component only re-renders when its props change. This is an effective way to optimize child components that rely on stable props.\n\nMemoization is the process of caching the results of functions or computations to reuse them when needed. The\n\n`useCallback`and\n\n`useMemo`hooks leverage memoization to improve the efficiency of function and value management by avoiding recalculating the same values on every render.\n\nWhen functions are passed as props to child components, React usually re-renders the child component on every parent render. The... `useCallback`hook caches these functions so that React does not unnecessarily re-create the same function, ensuring that the child component only re-renders when needed.\n\nIf an application performs intensive calculations, such as sorting, filtering, or searching within large datasets, the\n\n`useMemo`hook ensures that these computations only run when required. This reduces the computational overhead and keeps the UI responsive, as React uses the cached value until dependencies change.\n\nDevelopers who want to ensure that users have a positive user experience and keep them engaged in the application need to focus on improving application performance. React applications have a very fast UI by default, however, when the size of the application increases there might be performance issues.\n\nIn React, every time a component re-renders, all functions declared within that component are re-created. This behavior ensures that the component logic reflects the latest state, but it can lead to performance issues if the component is large or if certain functions are passed as props to child components. React does not re-render individual functions within a component. Instead, the entire component is re-rendered whenever its state or props change.\n\nIf a component has many functions, React recreates all of them on each render, even if some are not directly affected by the changes. This can make the application feel slower, especially when these functions are passed down to other components as props, causing child components to re-render unnecessarily. To avoid this scenario, we use the concept of memoization.... ## Optimizing functions with the\n\n`useCallback`hook\n\nTo understand the use of the\n\n. referential integrity Referential integrity is when we create two variables and compare them with each other and the answer would be true because they are just comparing the values and the data type. In the case of objects, when we create two objects and compare them, the result would be false as the objects are pointing to two different memory blocks. So, when a slight change is made every time, it creates a new object that has a new memory address‚Äî breaking the referential integrity when the shallow comparison of props is made. Hence, we have to re-render the whole component again.\n\n`useCallback`hook, you should have a slight understanding of the concept of\n\nWhen functions are passed as props to child components, React may re-render the child unnecessarily, even if the logic of the function hasn‚Äôt changed. This is where\n\n`useCallback`comes in. The\n\n`useCallback`hook memoizes a function, ensuring that it maintains the same reference across renders unless its dependencies change. This prevents React from triggering re-renders in child components that receive the function as a prop.\n\nThe syntax to define it is as follows:\n\nThe\n\n`useCallback`function has the following parameters:\n\n`fn`: The callback function to be memoized between the re-renders.\n\n`dependencies`: Values that determine when the function should be re-created.\n\nWhen we render our component first,\n\n`useCallback`will return the function passed to it. After every next render, it will compare the dependencies with the dependencies passed during the last render. If no dependency changes after comparison, it will return the old function. Now, throughout the lifetime of this component, the memoized callback function will always be the same function in the memory. We are never actually creating a new function but keeping this function over and over again at each render, even by different values. The function will stay referentially the same.\n\nLet‚Äôs look into an example of this to have a better understanding.... ## Frequently asked questions\n\nHaven‚Äôt found what you were looking for? Contact Us\n\n## When should I use useCallback in React?\n\nUse the\n\n`useCallback`hook when passing functions as props to prevent unnecessary re-renders of child components.\n\n## Can I use useEffect with useCallback or useMemo?\n\nYes! You can use\n\n`useEffect`hook alongside memoization hooks to run side effects based on memoized values or functions.\n\n## What‚Äôs the main difference between useMemo and useCallback?\n\nThe main difference between these two hooks is that the\n\n`useMemo`hook caches values while the\n\n`useCallback`hook caches functions.",
      "date": "2024-10-21"
    },
    {
      "title": "Built-in React Hooks",
      "url": "https://react.dev/reference/react/hooks",
      "snippet": "# Built-in React Hooks\n\n*Hooks* let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.\n\n## State Hooks\n\n*State* lets a component ‚Äúremember‚Äù information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\n\nTo add state to a component, use one of these Hooks:\n\n`useState`declares a state variable that you can update directly.\n\n`useReducer`declares a state variable with the update logic inside a reducer function.\n\n`function ImageGallery() {`\n\nconst [index, setIndex] = useState(0);\n\n// ...\n\n## Context Hooks\n\n*Context* lets a component receive information from distant parents without passing it as props. For example, your app‚Äôs top-level component can pass the current UI theme to all components below, no matter how deep.\n\n`useContext`reads and subscribes to a context.\n\n`function Button() {`\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n## Ref Hooks\n\n*Refs* let a component hold some information that isn‚Äôt used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an ‚Äúescape hatch‚Äù from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\n\n`useRef`declares a ref. You can hold any value in it, but most often it‚Äôs used to hold a DOM node.\n\n`useImperativeHandle`lets you customize the ref exposed by your component. This is rarely used.\n\n`function Form() {`\n\nconst inputRef = useRef(null);\n\n// ...... ## Effect Hooks\n\n*Effects* let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.\n\n`useEffect`connects a component to an external system.\n\n`function ChatRoom({ roomId }) {`\n\nuseEffect(() => {\n\nconst connection = createConnection(roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\n// ...\n\nEffects are an ‚Äúescape hatch‚Äù from the React paradigm. Don‚Äôt use Effects to orchestrate the data flow of your application. If you‚Äôre not interacting with an external system, you might not need an Effect.\n\nThere are two rarely used variations of\n\n`useEffect` with differences in timing:\n\n`useLayoutEffect`fires before the browser repaints the screen. You can measure layout here.\n\n`useInsertionEffect`fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\n\n## Performance Hooks\n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\n\n`useMemo`lets you cache the result of an expensive calculation.\n\n`useCallback`lets you cache a function definition before passing it down to an optimized component.\n\n`function TodoList({ todos, tab, theme }) {`\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n// ...\n\n\n\nSometimes, you can‚Äôt skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don‚Äôt need to block the user interface (like updating a chart).\n\nTo prioritize rendering, use one of these Hooks:\n\n`useTransition`lets you mark a state transition as non-blocking and allow other updates to interrupt it.\n\n`useDeferredValue`lets you defer updating a non-critical part of the UI and let other parts update first.... ## Other Hooks\n\nThese Hooks are mostly useful to library authors and aren‚Äôt commonly used in the application code.\n\n`useDebugValue`lets you customize the label React DevTools displays for your custom Hook.\n\n`useId`lets a component associate a unique ID with itself. Typically used with accessibility APIs.\n\n`useSyncExternalStore`lets a component subscribe to an external store.\n\n`useActionState`allows you to manage state of actions.\n\n## Your own Hooks\n\nYou can also define your own custom Hooks as JavaScript functions."
    },
    {
      "title": "Optimizing Performance",
      "url": "https://legacy.reactjs.org/docs/optimizing-performance.html",
      "snippet": "These docs are old and won‚Äôt be updated. Go to react.dev for the new React docs.\n\nThese new documentation pages teach modern React:\n\nInternally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.... ### Brunch\n\nFor the most efficient Brunch production build, install the\n\n`terser-brunch` plugin:\n\n```\n\n# If you use npm\n\nnpm install --save-dev terser-brunch\n\n# If you use Yarn\n\nyarn add --dev terser-brunch\n\n```\n\nThen, to create a production build, add the\n\n`-p` flag to the\n\n`build` command:\n\n`brunch build -p`\n\nRemember that you only need to do this for production builds. You shouldn‚Äôt pass the\n\n`-p` flag or apply this plugin in development, because it will hide useful React warnings and make the builds much slower.\n\n### Browserify\n\nFor the most efficient Browserify production build, install a few plugins:\n\n```\n\n# If you use npm\n\nnpm install --save-dev envify terser uglifyify\n\n# If you use Yarn\n\nyarn add --dev envify terser uglifyify\n\n```\n\nTo create a production build, make sure that you add these transforms\n\n**(the order matters)**:\n\n- The\n\n`envify`transform ensures the right build environment is set. Make it global (\n\n`-g`).\n\n- The\n\n`uglifyify`transform removes development imports. Make it global too (\n\n`-g`).\n\n- Finally, the resulting bundle is piped to\n\n`terser`for mangling (read why).\n\nFor example:\n\n```\n\nbrowserify ./index.js \\\n\n-g [ envify --NODE_ENV production ] \\\n\n-g uglifyify \\\n\n| terser --compress --mangle > ./bundle.js\n```\n\nRemember that you only need to do this for production builds. You shouldn‚Äôt apply these plugins in development because they will hide useful React warnings, and make the builds much slower.... ### Rollup\n\nFor the most efficient Rollup production build, install a few plugins:\n\n```\n\n# If you use npm\n\nnpm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser\n\n# If you use Yarn\n\nyarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser\n\n```\n\nTo create a production build, make sure that you add these plugins\n\n**(the order matters)**:\n\n- The\n\n`replace`plugin ensures the right build environment is set.\n\n- The\n\n`commonjs`plugin provides support for CommonJS in Rollup.\n\n- The\n\n`terser`plugin compresses and mangles the final bundle.\n\n```\n\nplugins: [\n\n// ...\n\nrequire('rollup-plugin-replace')({\n\n'process.env.NODE_ENV': JSON.stringify('production')\n\n}),\n\nrequire('rollup-plugin-commonjs')(),\n\nrequire('rollup-plugin-terser')(),\n\n// ...\n\n\n\n```\n\nFor a complete setup example see this gist.\n\nRemember that you only need to do this for production builds. You shouldn‚Äôt apply the\n\n`terser` plugin or the\n\n`replace` plugin with\n\n`'production'` value in development because they will hide useful React warnings, and make the builds much slower.\n\n### webpack\n\nNote:\n\nIf you‚Äôre using Create React App, please follow the instructions above.\n\nThis section is only relevant if you configure webpack directly.\n\nWebpack v4+ will minify your code by default in production mode.\n\n```\n\nconst TerserPlugin = require('terser-webpack-plugin');\n\nmodule.exports = {\n\nmode: 'production',\n\noptimization: {\n\nminimizer: [new TerserPlugin({ /* additional options here */ })],\n\n},\n\n};\n\n```\n\nYou can learn more about this in webpack documentation.\n\nRemember that you only need to do this for production builds. You shouldn‚Äôt apply\n\n`TerserPlugin` in development because it will hide useful React warnings, and make the builds much slower.... ## Avoid Reconciliation\n\nReact builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a ‚Äúvirtual DOM‚Äù, but it works the same way on React Native.\n\nWhen a component‚Äôs props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.\n\nEven though React only updates the changed DOM nodes, re-rendering still takes some time. In many cases it‚Äôs not a problem, but if the slowdown is noticeable, you can speed all of this up by overriding the lifecycle function\n\n`shouldComponentUpdate`, which is triggered before the re-rendering process starts. The default implementation of this function returns\n\n`true`, leaving React to perform the update:\n\n```\n\nshouldComponentUpdate(nextProps, nextState) {\n\nreturn true;\n\n\n\n```\n\nIf you know that in some situations your component doesn‚Äôt need to update, you can return\n\n`false` from\n\n`shouldComponentUpdate` instead, to skip the whole rendering process, including calling\n\n`render()` on this component and below.\n\nIn most cases, instead of writing\n\n`shouldComponentUpdate()` by hand, you can inherit from\n\n`React.PureComponent`. It is equivalent to implementing\n\n`shouldComponentUpdate()` with a shallow comparison of current and previous props and state.... `React.PureComponent`. So this code is a simpler way to achieve the same thing:\n\n```\n\nclass CounterButton extends React.PureComponent {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.state = {count: 1};\n\n\n\nrender() {\n\nreturn (\n\n<button\n\ncolor={this.props.color}\n\nonClick={() => this.setState(state => ({count: state.count + 1}))}>\n\nCount: {this.state.count}\n\n</button>\n\n);\n\n\n\n```\n\nMost of the time, you can use\n\n`React.PureComponent` instead of writing your own\n\n`shouldComponentUpdate`. It only does a shallow comparison, so you can‚Äôt use it if the props or state may have been mutated in a way that a shallow comparison would miss.\n\nThis can be a problem with more complex data structures. For example, let‚Äôs say you want a\n\n`ListOfWords` component to render a comma-separated list of words, with a parent\n\n`WordAdder` component that lets you click a button to add a word to the list. This code does\n\n*not* work correctly:\n\n```\n\nclass ListOfWords extends React.PureComponent {\n\nrender() {\n\nreturn <div>{this.props.words.join(',')}</div>;\n\n\n\nclass WordAdder extends React.Component {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.state = {\n\nwords: ['marklar']\n\n};\n\nthis.handleClick = this.handleClick.bind(this);\n\n\n\nhandleClick() {\n\n// This section is bad style and causes a bug\n\nconst words = this.state.words;\n\nwords.push('marklar');\n\nthis.setState({words: words});\n\n\n\nrender() {\n\nreturn (\n\n<div>\n\n<button onClick={this.handleClick} />\n\n<ListOfWords words={this.state.words} />\n\n</div>\n\n);\n\n\n\n```\n\nThe problem is that\n\n`PureComponent` will do a simple comparison between the old and new values of\n\n`this.props.words`. Since this code mutates the\n\n`words` array in the\n\n`handleClick` method of\n\n`WordAdder`, the old and new values of\n\n`this.props.words` will compare as equal, even though the actual words in the array have changed. The\n\n`ListOfWords` will thus not update even though it has new words that should be rendered.... ## The Power Of Not Mutating Data\n\nThe simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the\n\n`handleClick` method above could be rewritten using\n\n`concat` as:\n\n```\n\nhandleClick() {\n\nthis.setState(state => ({\n\nwords: state.words.concat(['marklar'])\n\n}));\n\n\n\n```\n\nES6 supports a spread syntax for arrays which can make this easier. If you‚Äôre using Create React App, this syntax is available by default.\n\n```\n\nhandleClick() {\n\nthis.setState(state => ({\n\nwords: [...state.words, 'marklar'],\n\n}));\n\n};\n\n```\n\nYou can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let‚Äôs say we have an object named\n\n`colormap` and we want to write a function that changes\n\n`colormap.right` to be\n\n`'blue'`. We could write:\n\n```\n\nfunction updateColorMap(colormap) {\n\ncolormap.right = 'blue';\n\n\n\n```\n\nTo write this without mutating the original object, we can use Object.assign method:\n\n```\n\nfunction updateColorMap(colormap) {\n\nreturn Object.assign({}, colormap, {right: 'blue'});\n\n\n\n```\n\n`updateColorMap` now returns a new object, rather than mutating the old one.\n\n`Object.assign` is in ES6 and requires a polyfill.\n\nObject spread syntax makes it easier to update objects without mutation as well:\n\n```\n\nfunction updateColorMap(colormap) {\n\nreturn {...colormap, right: 'blue'};\n\n\n\n```\n\nThis feature was added to JavaScript in ES2018.\n\nIf you‚Äôre using Create React App, both\n\n`Object.assign` and the object spread syntax are available by default.\n\nWhen you deal with deeply nested objects, updating them in an immutable way can feel convoluted. If you run into this problem, check out Immer or immutability-helper. These libraries let you write highly readable code without losing the benefits of immutability.",
      "date": "2021-08-16"
    },
    {
      "title": "Why custom react hooks could destroy your app performance",
      "url": "https://www.developerway.com/posts/why-custom-react-hooks-could-destroy-your-app-performance",
      "snippet": "# Why custom react hooks could destroy your app performance\n\nNadia Makarevich\n\nScary title, isn‚Äôt it? The sad part is that it‚Äôs true: for performance-sensitive apps custom React hooks can very easily turn into the biggest performance killer, if not written and used very carefully.\n\nI‚Äôm not going to explain how to build and use hooks here, if you never built a hook before, the React docs have a pretty good introduction into it. What I want to focus on today is their performance implication for complicated apps.... ## Let‚Äôs build a modal dialog on custom hooks\n\nEssentially, hooks are just advanced functions that allow developers to use things like state and context without creating new components. They are super useful when you need to share the same piece of logic that needs state between different parts of the app. With hooks came a new era in React development: never before our components were as slim and neat as with hooks, and separation of different concerns was as easy to achieve as with hooks.\n\nLet‚Äôs for example, implement a modal dialog. With custom hooks, we can create a piece of beauty here.\n\nFirst, let‚Äôs implement a ‚Äúbase‚Äù component, that doesn‚Äôt have any state, but just renders the dialog when\n\n`isOpen` prop is provided and triggers\n\n`onClose` callback when a click on a blanket underneath the dialog happens.\n\ntype ModalProps = { isOpen: boolean; onClosed: () => void;}; export const ModalBase = ({ isOpen, onClosed,}: ModalProps) => { return isOpen ? ( <> <div css={modalBlanketCss} onClick={onClosed} /> <div css={modalBodyCss}>Modal dialog content</div> </> ) : null;};\n\nNow to the state management, i.e. the ‚Äúopen dialog/close dialog‚Äù logic. In the ‚Äúold‚Äù way we would usually implement a ‚Äúsmart‚Äù version of it, which handles the state management and accepts a component that is supposed to trigger the opening of the dialog as a prop. Something like this:... ## Adding more functionality to the\n\n`useModal` hook\n\nLet‚Äôs make our hooks performance conversation slightly darker üôÇ. Imagine, for example, you need to track the scroll event in the modal content. Maybe you want to send some analytics events when the users scroll through the text, to track reads. What will happen if I don‚Äôt want to introduce ‚Äúsmart‚Äù functionality to the\n\n`BaseModal` and do it in the\n\n`useModal` hook?\n\nRelatively easy to achieve. We can just introduce a new state there to track scroll position, add event listeners in\n\n`useEffect` hook and pass ref to the\n\n`BaseModal` to get the content element to attach the listeners to. Something like this:\n\nexport const ModalBase = React.forwardRef( ( { isOpen, onClosed }: ModalProps, ref: RefObject<any>, ) => { return isOpen ? ( <> <div css={modalBlanketCss} onClick={onClosed} /> <div css={modalBodyCss} ref={ref}> // add a lot of content here </div> </> ) : null; },); export const useModal = () => { const [isOpen, setIsOpen] = useState(false); const ref = useRef<HTMLElement>(null); const [scroll, setScroll] = useState(0); // same as before useEffect(() => { const element = ref.current; if (!element) return; const handleScroll = () => { setScroll(element?.scrollTop || 0); }; element.addEventListener('scroll', handleScroll); return () => { element.removeEventListener('scroll', handleScroll); }; }); const Dialog = () => ( <ModalBase onClosed={close} isOpen={isOpen} ref={ref} /> ); return { isOpen, Dialog, open, close, };};... And now we can do whatever with this state. Now let‚Äôs pretend that the previous performance problems are not that big of a deal, and use again this hook directly in the slow Page component. See codesandbox.\n\nThe scrolling doesn‚Äôt even work properly! üò± Every time I try to scroll the dialog content it resets to the top!\n\nOkay, let‚Äôs think logically. We know already, that creating components inside render functions is evil, since React will re-create and re-mount them on every re-render. And we know that hooks change with every state change. That means now, when we introduced scroll state, on every scroll change we‚Äôre changing state, which causes the hook to re-render, which causes\n\n`Dialog` component to re-create itself. Exactly the same problem, as with creating components inside render functions, with exactly the same fix: we need to extract this component outside of the hook or just memoise it.\n\nconst Dialog = useMemo(() => { return () => ( <ModalBase onClosed={close} isOpen={isOpen} ref={ref} /> );}, [isOpen]);\n\nThe focus behaviour is fixed, but there is another problem here: the slow\n\n`Page` component re-renders on every scroll! That one is a bit hard to notice since the dialog content is just text. Try, for example, to reduce the CPU by 6x, scroll, and then just highlight the text in the dialog right away. The browser won‚Äôt even allow that, since it‚Äôs too busy with re-renders of the underneath... `Page` component! See the codesandbox. And after a few scrolls, your laptop will probably try to take off to the Moon due to 100% CPU load üòÖ\n\nYeah, we definitely need to fix that before releasing it to production. Let‚Äôs take another look at our component, especially at this part:\n\nreturn { isOpen, Dialog, open, close,};\n\nWe‚Äôre returning a new object on every re-render, and since we re-render our hook on every scroll now, that means that object changes on every scroll as well. But we‚Äôre not using the scroll state here, it‚Äôs entirely internal for the\n\n`useModal` hook. Surely just memoising that object will solve the problem?\n\nreturn useMemo( () => ({ isOpen, Dialog, open, close, }), [isOpen, Dialog],);\n\nYou know the best (or the scariest) part of this? IT DIDN‚ÄôT! üò± See the codesandbox.\n\nAnd this is another huge performance-related bummer with hooks. Turns out, it doesn‚Äôt really matter, whether the state change in hooks is ‚Äúinternal‚Äù or not.\n\n**Every state change in a hook, whether it affects its return value or not, will cause the ‚Äúhost‚Äù component to re-render.**... And of course exactly the same story with chaining hooks: if a hook‚Äôs state changes, it will cause its ‚Äúhost‚Äù hook change as well, which will propagate up through the whole chain of hooks until it reaches the ‚Äúhost‚Äù component and re-renders it (which will cause another chain reaction of re-renders, only downstream now),\n\n**regardless of any memoisation** applied in between.\n\nExtracting the ‚Äúscrolling‚Äù functionality into a hook will make absolutely no difference, the slow Page component will re-render üòî.\n\nconst useScroll = (ref: RefObject) => { const [scroll, setScroll] = useState(0); useEffect(() => { const element = ref.current; if (!element) return; const handleScroll = () => { setScroll(element?.scrollTop || 0); }; element.addEventListener('scroll', handleScroll); return () => { element.removeEventListener('scroll', handleScroll); }; }); return scroll;}; export const useModal = () => { const [isOpen, setIsOpen] = useState(false); const ref = useRef<HTMLElement>(null); const scroll = useScroll(ref); const open = useCallback(() => { setIsOpen(true); }, []); const close = useCallback(() => { setIsOpen(false); }, []); const Dialog = useMemo(() => { return () => ( <ModalBase onClosed={close} isOpen={isOpen} ref={ref} /> ); }, [isOpen, close]); return useMemo( () => ({ isOpen, Dialog, open, close, }), [isOpen, Dialog, open, close], );};... That is all for today! Hope this article\n\n~~scared you enough~~ helped you to feel more comfortable with custom hooks and how to write and use them without compromising the performance of your apps. Let‚Äôs recap the rules of performant hooks before leaving:\n\n- every state change in a hook will cause its ‚Äúhost‚Äù component to re-render, regardless of whether this state is returned in the hook value and memoised or not\n\n- the same with chained hooks, every state change in a hook will cause all ‚Äúparent‚Äù hooks to change until it reaches the ‚Äúhost‚Äù component, which again will trigger the re-render\n\nAnd the things to watch out for, when writing or using custom hooks:\n\n- when using a custom hook, make sure that the state that this hook encapsulates is not used on the level it wouldn‚Äôt have been used with the components approach. Move it ‚Äúdown‚Äù to a smaller component if necessary\n\n- never implement ‚Äúindependent‚Äù state in a hook or use hooks with the independent state\n\n- when using a custom hook, make sure it doesn‚Äôt perform some independent state operations, that are not exposed in its return value\n\n- when using a custom hook, make sure that all hooks that it uses also follow the rules from the above\n\nStay safe and may your apps be blazing fast from now on! ‚úåüèº... ### Want to learn even more?\n\n#### Web Performance Fundamentals\n\nA Frontend Developer‚Äôs Guide to Profile and Optimize React Web Apps\n\n#### Advanced React\n\nDeep dives, investigations, performance patterns and techniques.\n\n#### Advanced React Mini-Course\n\nFree YouTube mini-course following first seven chapters of the Advanced React book",
      "date": "2022-01-24"
    }
  ],
  "metadata": {
    "timestamp": "2025-10-16T17:27:28.629Z",
    "queryCount": 1,
    "totalResults": 5,
    "executionTime": 514.938982,
    "success": true
  },
  "includeTimestamp": true,
  "includeMetadata": true
}